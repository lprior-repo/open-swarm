// Copyright (c) 2025 Open Swarm Contributors
//
// This software is released under the MIT License.
// See LICENSE file in the repository for details.

package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"os/signal"
	"path/filepath"
	"syscall"

	"open-swarm/internal/agent"
	"open-swarm/internal/infra"
	"open-swarm/internal/workflow"
)

const (
	// Configuration constants from Tessl spec
	MaxConcurrentAgents = 50
	PortRangeMin        = 8000
	PortRangeMax        = 9000
)

type Config struct {
	RepoDir      string
	WorktreeBase string
	Branch       string
	MaxAgents    int
}

func main() {
	// Parse command line flags
	var (
		repoDir      = flag.String("repo", ".", "Git repository directory")
		worktreeBase = flag.String("worktrees", "./worktrees", "Base directory for worktrees")
		branch       = flag.String("branch", "main", "Branch to use for worktrees")
		maxAgents    = flag.Int("max-agents", MaxConcurrentAgents, "Maximum concurrent agents")
		taskID       = flag.String("task", "", "Task ID to execute")
		taskDesc     = flag.String("desc", "", "Task description")
		taskPrompt   = flag.String("prompt", "", "Task prompt")
		// Note: parallel mode not yet implemented in simplified version
		_ = flag.Bool("parallel", false, "Run tasks in parallel mode (not yet implemented)")
	)
	flag.Parse()

	config := &Config{
		RepoDir:      *repoDir,
		WorktreeBase: *worktreeBase,
		Branch:       *branch,
		MaxAgents:    *maxAgents,
	}

	log.Printf("üöÄ Reactor-SDK v6.0.0 - Enterprise Agent Orchestrator")
	log.Printf("üìä Configuration:")
	log.Printf("   Repository: %s", config.RepoDir)
	log.Printf("   Worktree Base: %s", config.WorktreeBase)
	log.Printf("   Branch: %s", config.Branch)
	log.Printf("   Max Agents: %d", config.MaxAgents)
	log.Printf("   Port Range: %d-%d", PortRangeMin, PortRangeMax)

	// Validate inputs
	if *taskID == "" || *taskPrompt == "" {
		log.Fatal("‚ùå Error: --task and --prompt are required")
	}

	// Initialize infrastructure
	log.Println("üîß Initializing infrastructure...")

	portManager := infra.NewPortManager(PortRangeMin, PortRangeMax)
	serverManager := infra.NewServerManager()
	worktreeManager := infra.NewWorktreeManager(config.RepoDir, config.WorktreeBase)

	// Cleanup any existing worktrees
	log.Println("üßπ Cleaning up existing worktrees...")
	if err := worktreeManager.CleanupAll(); err != nil {
		log.Printf("‚ö†Ô∏è  Warning: Failed to cleanup worktrees: %v", err)
	}

	// Create workflow backend
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Handle shutdown signals
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	go func() {
		<-sigChan
		log.Println("\nüõë Shutdown signal received, cleaning up...")
		cancel()
	}()

	// Initialize workflow engine
	log.Println("‚öôÔ∏è  Initializing workflow engine...")

	// Note: For simplicity, we'll use a basic task execution without the full workflow engine
	// In production, you would use the full go-workflows backend

	// Execute task directly
	log.Println("üéØ Starting task execution...")

	task := &agent.TaskContext{
		TaskID:      *taskID,
		Description: *taskDesc,
		Prompt:      *taskPrompt,
	}

	activities := workflow.NewActivities(portManager, serverManager, worktreeManager)

	// Bootstrap cell
	log.Println("üì¶ Bootstrapping agent cell...")
	cell, err := activities.BootstrapCell(ctx, "primary", config.Branch)
	if err != nil {
		log.Fatalf("‚ùå Failed to bootstrap cell: %v", err)
	}
	defer func() {
		log.Println("üßπ Tearing down cell...")
		if err := activities.TeardownCell(ctx, cell); err != nil {
			log.Printf("‚ö†Ô∏è  Warning: Failed to teardown cell: %v", err)
		}
	}()

	log.Printf("‚úÖ Cell bootstrapped on port %d", cell.Port)
	log.Printf("üìÅ Worktree: %s", cell.WorktreePath)

	// Execute task
	log.Println("‚öôÔ∏è  Executing task...")
	result, err := activities.ExecuteTask(ctx, cell, task)
	if err != nil {
		log.Fatalf("‚ùå Task execution failed: %v", err)
	}

	if !result.Success {
		log.Printf("‚ùå Task failed: %s", result.ErrorMessage)
		os.Exit(1)
	}

	log.Println("‚úÖ Task completed successfully")
	log.Printf("üìù Output:\n%s", result.Output)

	if len(result.FilesModified) > 0 {
		log.Println("üìÅ Modified files:")
		for _, file := range result.FilesModified {
			log.Printf("   - %s", file)
		}
	}

	// Run tests
	log.Println("üß™ Running tests...")
	testsPassed, err := activities.RunTests(ctx, cell)
	if err != nil {
		log.Printf("‚ö†Ô∏è  Test execution failed: %v", err)
		testsPassed = false
	}

	if testsPassed {
		log.Println("‚úÖ Tests passed")

		// Commit changes
		log.Println("üíæ Committing changes...")
		commitMsg := fmt.Sprintf("Task %s: %s\n\nü§ñ Generated by Reactor-SDK", *taskID, *taskDesc)
		if err := activities.CommitChanges(ctx, cell, commitMsg); err != nil {
			log.Printf("‚ö†Ô∏è  Commit failed: %v", err)
		} else {
			log.Println("‚úÖ Changes committed")
		}
	} else {
		log.Println("‚ùå Tests failed")

		// Revert changes
		log.Println("‚Ü©Ô∏è  Reverting changes...")
		if err := activities.RevertChanges(ctx, cell); err != nil {
			log.Printf("‚ö†Ô∏è  Revert failed: %v", err)
		} else {
			log.Println("‚úÖ Changes reverted")
		}
	}

	log.Println("\n‚úÖ Reactor execution complete")
}

func absPath(path string) string {
	abs, err := filepath.Abs(path)
	if err != nil {
		return path
	}
	return abs
}
