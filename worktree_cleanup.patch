--- a/internal/mergequeue/coordinator.go
+++ b/internal/mergequeue/coordinator.go
@@ -4,6 +4,9 @@ import (
 	"context"
 	"fmt"
+	"path/filepath"
 	"sync"
 	"time"
+
+	"github.com/open-swarm/open-swarm/internal/infra"
 )

@@ -41,6 +44,9 @@ type Coordinator struct {
 	// Metrics
 	stats QueueStats

+	// Worktree manager for git worktree cleanup
+	worktreeManager infra.WorktreeManagerInterface
+
 	// Channels for coordination
 	changesChan  chan *ChangeRequest
@@ -73,6 +79,9 @@ type CoordinatorConfig struct {
 	// Test timeout per change (default 5 minutes)
 	TestTimeout time.Duration
+
+	// Worktree manager (optional, for cleanup)
+	WorktreeManager infra.WorktreeManagerInterface
 }

 // NewCoordinator creates a new merge queue coordinator
@@ -100,6 +109,7 @@ func NewCoordinator(config CoordinatorConfig) *Coordinator {
 		mainQueue:      make([]*ChangeRequest, 0),
 		bypassLane:     make([]*ChangeRequest, 0),
 		activeBranches: make(map[string]*SpeculativeBranch),
 		config:         config,
+		worktreeManager: config.WorktreeManager,
 		changesChan:    make(chan *ChangeRequest, defaultChannelCapacity),
 		resultsChan:    make(chan *TestResult, defaultChannelCapacity),
@@ -352,7 +362,21 @@ func (c *Coordinator) killFailedBranch(_ context.Context, branchID string, reas

 	// TODO: Cancel Temporal workflow
 	// TODO: Stop Docker container
-	// TODO: Clean up worktree
+
+	// Clean up worktrees for all changes in this branch
+	if c.worktreeManager != nil {
+		for _, change := range branch.Changes {
+			if change.WorktreePath != "" {
+				// Extract worktree ID from path (assumes path is /base/dir/worktreeID)
+				worktreeID := filepath.Base(change.WorktreePath)
+				if worktreeID != "" && worktreeID != "." && worktreeID != "/" {
+					if err := c.worktreeManager.RemoveWorktree(worktreeID); err != nil {
+						// Log error but continue with other cleanup
+						// The worktree may have already been removed
+					}
+				}
+			}
+		}
+	}

 	// Update branch status
