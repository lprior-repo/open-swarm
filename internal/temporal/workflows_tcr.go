package temporal

import (
	"fmt"
	"time"

	"go.temporal.io/sdk/temporal"
	"go.temporal.io/sdk/workflow"
)

// TCRWorkflowInput defines input for Test-Commit-Revert workflow
type TCRWorkflowInput struct {
	CellID      string
	Branch      string
	TaskID      string
	Description string
	Prompt      string
}

// TCRWorkflowResult contains the workflow result
type TCRWorkflowResult struct {
	Success      bool
	TestsPassed  bool
	FilesChanged []string
	Error        string
}

// TCRWorkflow implements the traditional Test-Commit-Revert pattern
// Bootstrap â†’ Execute â†’ Test â†’ (Commit|Revert) â†’ Teardown
func TCRWorkflow(ctx workflow.Context, input TCRWorkflowInput) (*TCRWorkflowResult, error) {
	logger := workflow.GetLogger(ctx)
	logger.Info("Starting TCR Workflow", "taskID", input.TaskID)

	// Activity options
	ao := workflow.ActivityOptions{
		StartToCloseTimeout: 10 * time.Minute,
		HeartbeatTimeout:    30 * time.Second,
		RetryPolicy: &temporal.RetryPolicy{
			MaximumAttempts: 1, // Don't retry non-idempotent operations
		},
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	cellActivities := NewCellActivities()

	// Step 1: Bootstrap Cell
	var bootstrap *BootstrapOutput
	err := workflow.ExecuteActivity(ctx, cellActivities.BootstrapCell, BootstrapInput{
		CellID: input.CellID,
		Branch: input.Branch,
	}).Get(ctx, &bootstrap)

	if err != nil {
		return &TCRWorkflowResult{
			Success: false,
			Error:   fmt.Sprintf("bootstrap failed: %v", err),
		}, nil
	}

	// Ensure teardown happens (saga pattern)
	defer func() {
		// Use disconnected context for cleanup
		disconnCtx, _ := workflow.NewDisconnectedContext(ctx)
		teardownAo := workflow.ActivityOptions{
			StartToCloseTimeout: 2 * time.Minute,
			RetryPolicy: &temporal.RetryPolicy{
				MaximumAttempts: 3,
			},
		}
		disconnCtx = workflow.WithActivityOptions(disconnCtx, teardownAo)

		logger.Info("Tearing down cell", "cellID", bootstrap.CellID)
		_ = workflow.ExecuteActivity(disconnCtx, cellActivities.TeardownCell, bootstrap).Get(disconnCtx, nil)
	}()

	// Step 2: Execute Task
	var execResult *TaskOutput
	err = workflow.ExecuteActivity(ctx, cellActivities.ExecuteTask, bootstrap, TaskInput{
		TaskID:      input.TaskID,
		Description: input.Description,
		Prompt:      input.Prompt,
	}).Get(ctx, &execResult)

	if err != nil || !execResult.Success {
		return &TCRWorkflowResult{
			Success: false,
			Error:   execResult.ErrorMessage,
		}, nil
	}

	// Step 3: Run Tests
	var testsPassed bool
	err = workflow.ExecuteActivity(ctx, cellActivities.RunTests, bootstrap).Get(ctx, &testsPassed)
	if err != nil {
		return &TCRWorkflowResult{
			Success: false,
			Error:   fmt.Sprintf("tests failed to run: %v", err),
		}, nil
	}

	// Step 4: Commit or Revert based on test results
	if testsPassed {
		commitMsg := fmt.Sprintf("Task %s: %s\n\nðŸ¤– Generated by Reactor-SDK", input.TaskID, input.Description)
		err = workflow.ExecuteActivity(ctx, cellActivities.CommitChanges, bootstrap, commitMsg).Get(ctx, nil)
		if err != nil {
			logger.Warn("Commit failed", "error", err)
		} else {
			logger.Info("Changes committed successfully")
		}
	} else {
		logger.Info("Tests failed, reverting changes")
		err = workflow.ExecuteActivity(ctx, cellActivities.RevertChanges, bootstrap).Get(ctx, nil)
		if err != nil {
			logger.Warn("Revert failed", "error", err)
		}
	}

	return &TCRWorkflowResult{
		Success:      testsPassed,
		TestsPassed:  testsPassed,
		FilesChanged: execResult.FilesModified,
	}, nil
}
